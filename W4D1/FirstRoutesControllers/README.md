# First Routes & Controllers

In this project we'll start playing with Rails routing.

[aa-contactsapi]: http://aa-contactsapi.herokuapp.com

## Learning Goals

* Be able to create routes in `routes.rb`
* Be able to read and understand Rails server error messages
* Know the three places that `params` come from
* Be able to nest query parameters
* Be able to write controller actions that read from and write to the database
* Know how and when to render errors

## Rails Diagram

As you work through the project, revisit this diagram at each phase and
discuss with your pair how the code you've written so far fits into the
relationships displayed here.

![rails diagram](../../assets/rails_diagram.png)

## First Routes

To start, generate a new, blank Rails project. **Make sure to use Postgres as your
database.** You can do this by appending `--database=postgresql` to the end of your
`rails new project_name` command. When using Postgres, you then need to setup
the database by running `bundle exec rails db:create`.

Go to `config/routes.rb` and generate your first routes with:

```ruby
resources :users
```

Remember that this one line actually generates **eight routes** for
us. Run `bundle exec rails routes` to see what those routes are.

Woohoo! We've set up our first eight **API endpoints**. Each route you
have is an API endpoint, which encapsulates a single action your app
can take.

Lest you scream "magic!", do the following:

* Comment out the `resources :users` line.
* Write out the eight routes using the route 'matching' syntax.  For
  example: `get 'users/:id', to: 'users#show', as: 'user'`.

Run `bundle exec rails routes` again and ensure that the routes you've written
match exactly the routes generated by the `resources` helper. **NB**:
you'll probably be missing some names for some of the routes (they're
listed in the left-most column); You can name your routes by adding an
`as` option. `get 'users/new', to:  'users#new', as: 'new_user'`.

Remember that all a route does is match on the **HTTP method** and the
**url path** (it does this with a **regular expression**, if you know
what that is already). The controller then sends the request on to the
specified action on the specified controller.

We have our initial routes now and have the endpoints necessary to
manage a `User` resource. Notice though that our routes point to a
`UsersController`, which we don't actually have yet. Nor do we have a
`User` model. We'll add that later, too. Soon!

## First Controller

Each API endpoint creates/reads/updates/destroys (CRUD) a resource.

The router defines API endpoints (URLs), and records which controller
and action to invoke for each one. Each API endpoint has a conventional meaning:
create/read/update/destroy a resource. The controllers and their
actions are the ones actually doing the **CRUD** ing.

Generate your first controller with:

```
$ rails generate controller Users
```

Note that controllers are always plural; a controller manages requests
that pertain to a collection of **resources**. A resource is anything
in your application that you will be CRUDing.

Let's go take a look at the controller that was generated.

```ruby
# app/controllers/users_controller.rb
class UsersController < ApplicationController
end
```

Controllers inherit from `ApplicationController` which is a controller
itself, but one that never actually handles any requests directly.
`ApplicationController` is where you'd put helper methods that you
want to share across all controllers. Take a look at it (it's right
there in the `app/controllers` folder):

```ruby
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
end
```

`ActionController::Base` provides all the bells & whistles that Rails
controllers have; it's like `ActiveRecord::Base` in that respect.  All
your controllers will inherit the features it provides since it is in
the inheritance chain:

```
  UsersController < ApplicationController < ActionController::Base
```

`protect_from_forgery` helps protect against cross-site request
forgery (CSRF) by checking the authenticity of a certain token for
POST requests. We won't worry about that for now.

**Just for this assignment, comment out `protect_from_forgery`.** Then
you won't need to include the authenticity token in your POST params;
we'll learn about what that means later.

Alright, now that we have some routes and a matching controller, we
have everything we need to start handling requests.

## First Launch

We have our API endpoints setup and they map to a controller which
we've created. How do we actually start taking requests?

```
$ rails server
=> Booting Puma
=> Rails 5.1.2 application starting in development on http://localhost:3000
=> Run `rails server -h` for more startup options
Puma starting in single mode...
* Version 3.9.1 (ruby 2.3.1-p112), codename: Private Caller
* Min threads: 5, max threads: 5
* Environment: development
* Listening on tcp://0.0.0.0:3000
Use Ctrl-C to stop
```

Rails 5 ships with a web server called Puma.

As you can see, it loads your application in development mode (later
we'll discuss the other two modes: production and testing), and is
listening for requests at `http://0.0.0.0:3000`. The last part,
`:3000` specifies the port it is listening on. Rails defaults to port
3000 in development. The domain `http://0.0.0.0` can be accessed from
your browser as simply `http://localhost`.

In your browser, navigate to `http://localhost:3000`. Voila! A
running Rails app with what will become a very familiar index page.

## First Request

Postman should already be installed, but if not, go ahead and [install it][postman].

[postman]: https://www.getpostman.com/

Now let's try to get a list of all our users - our **users index**. This means we need
to make a request that matches the HTTP verb and URI pattern that routes to
'UsersController#index'. If we `bundle exec rails routes`, we can see this is a `GET` request to
'/users'. Go ahead and make that request with Postman. (Make sure to keep your rails
server running in a terminal tab!)

Okay, that didn't work. Why?

The server log will be where you'll go to see what's going on in your
application. All your `puts` and `p` statements in your application
will also go to the server log. **Always be looking at the server
log**; this is an essential debugging technique. We'll see what some
of the most important information is in just a second. Here's what we
see in the log:

```
Started GET "/users.html" for 127.0.0.1 at 2013-08-12 10:48:39 -0700

AbstractController::ActionNotFound - The action 'index' could not be found for UsersController:
...
```

Looks like a request came in; what's the error? It seems like it's
complaining that we don't actually have an `index` action setup in our
`UsersController`. Note that your application looked for an index
action because the router specified that a GET request to `/users` maps
to `users#index`, which is the Rails shorthand for `UsersController#index`.

Let's fix it. Add an empty `index` action to your `UsersController`:

```ruby
class UsersController < ApplicationController
  def index
  end
end
```

Make the request in Postman again. It fails again, so look at the log:

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 11:36:40 -0700
Processing by UsersController#index as */*
No template found for UsersController#index, rendering head :no_content
Completed 204 No Content in 178ms
...
```

**NB:** If you make a GET request through a browser at this point, you will get a 406 Not Acceptable status code.

This time, it's complaining that there's a missing template. Wait a
minute; we never called `render`. Why is it trying to look for a
template at all? Because in the absence of an explicit `render`
statement, your controller will by default try to render a template
with the same name as the controller action - in this case, it was
looking for a template called `index.html.erb` in `app/views/users`.

We're not going to deal with views and templates just yet. To get rid
of this error, let's just add a simple render:

```ruby
class UsersController < ApplicationController
  def index
    render plain: "I'm in the index action!"
  end
end
```

Try again. It should work! Now take a look at the server log.

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 11:43:06 -0700
Processing by UsersController#index as HTML
  Rendering text template
  Rendered text template (0.0ms)
Completed 200 OK in 1ms (Views: 0.6ms)
```

For every request, the server will tell you which controller and
action is processing it. In this case, it was the `UsersController`'s
`index` action.

Woohoo! Your Postman request should have returned the string "I'm in
the index action!" Victory is yours. Congratulations on successfully
setting up, making, and processing your first Rails request.

## Playing with Parameters

Now we're going to focus on how data comes into our controllers from
the outside world.

The key method here is `#params`. `#params` is a method provided by
`ActionController::Base` that returns a hash of all the parameters
available. The parameters are complied by the router and are sourced
from three places:

* Route parameters (e.g. the `:id` from `/users/:id`)
* Query string (the part of the URL after the `?`: `?key=value`)
* POST/PATCH request data (the body of the HTTP request).

Go ahead and make some GET requests to `/users` playing around with
the query values. Put some key/value pairs in the query string - e.g.
`/users?fav_food=pizza` or `/users?admin=true`.

Check out the server log and notice that it logs
how the parameters are coming in:

```
Started GET "/users?favorite_food=pizza" for 127.0.0.1 at 2017-07-14 11:51:31 -0700
Processing by UsersController#index as */*
  Parameters: {"favorite_food"=>"pizza"}
  Rendering text template
  Rendered text template (0.0ms)
Completed 200 OK in 2ms (Views: 1.3ms)
```

Now make some POST requests to `/users` playing around with POST data
and seeing how the parameters come in. This means putting the data not in the
query string, but in the request body. Click on the 'Body' tab in Postman, and
enter the key/value pairs there. Make sure to change the HTTP verb to POST.

Think about what controller action we will hit when we make a POST request to `/users`
(check your routes again). Once again, we'll get the error that this action is not
defined on our `UsersController`:

```
Started POST "/users" for ::1 at 2017-06-19 10:09:29 -0700

AbstractController::ActionNotFound (The action 'create' could not be found for UsersController):
...
```

Go ahead and add that method to the controller. Again, if we don't explicitly render or
redirect, Rails is going to try to render the template with the same name; it's going
to look for `create.html.erb` in our `app/views/users` folder, which we don't have. To
prevent this, we need to explicitly render something simple back. In this case, let's go
ahead and render the params that came in with the request back. We can `render json:`, which
will automatically call `to_json` on the object we're rendering (in this case, our params hash)
and package it up for us so that it can be sent back with the response:

```ruby
class UsersController < ApplicationController
  def create
    render json: params
  end
end
```

Try making the request in Postman again. You should see the right response now!

```
{
  "fav_food": "pizza",
  "controller": "users",
  "action": "create"
}
```

Okay, now we've seen params come from the query string and the request body. Let's
see them come from the third and final place they can come from: the route params.

When we have `show`, `delete`, and `update` resources, Rails constructs URI patterns
for these that include a "wildcard" matcher. If we look at our routes, we can see these
wherever the URI pattern is `users/:id(format)`. The `:id` indicates that the router will match
anything put into that part of the URL and save it in the params under the key `id`.

Let's try making a GET request to `/users/:id`. In Postman, this means setting the URL to
something like '/users/2', where 2 is the `id` of the `User` we want to see.

Once again we get the same error. We are matching the `UsersController#show` route, but we
don't have that action defined on the controller. Go ahead and add it, and once again
`render json: params`. Now try the request again. We see the `:id` matcher saved the `2` from
our URL in the params!

```
{
  "controller": "users",
  "action": "show",
  "id": "2"
}
```

### Nesting Parameters

Notice how all of our parameters come in at the top level of the
parameters hash. Let's say we wanted to structure it a bit differently
so that certain parameters came in nested under others (hash within
a hash) like so:

```
{
  'id': 5,
  'some_category': {
    'a_key': 'another value',
    'a_second_key': 'yet another value',
    'inner_inner_hash': {
      'key': 'value'
    }
  },
  'something_else': 'aaahhhhh'
}
```

Here's how we would accomplish that:

```
<!-- in Postman's "Body" tab: -->
some_category[a_key]: 'another value'
some_category[a_second_key]: 'yet another value'
some_category[inner_inner_hash][key]: 'value'
something_else: 'aaahhhhh'

<!-- in the query string -->
'/users?some_category[a_key]=another+key&some_category[a_second_key]=yet+another_value'
<!-- ...etc. -->
```

If we follow this bracket notation, Rails will nest parameters for
us. The rule is that the keys with brackets gets nested deeper in the
params.

Try it out a few times with both GETs and POSTs. Make sure you're looking
at the params that came in with the request, either through your controller
action's rendering them back as JSON to Postman or in the server logs.

## Using Models

So, now we know how to set up routes, how to set up matching
controller actions, how to send and process incoming data through
parameters, and how to render something back to the requester. Let's
mix in some models.

Build a `User` model with name and email. Write a migration to add
columns for `name` and `email`. Migrate your database and add a couple
users through the console. Add validations for presence of name and
email.

In your `UsersController#index`, fetch all the users from the database
and render them as JSON. Remember that when you hand `render json:`
anything, it automatically calls `to_json` on it for you.

Make the request in Postman and make sure you're getting the right
JSON back. Check your server log and note that the SQL that ran is
logged there for you. All SQL queries your app makes will show up in
the server log - yet another useful piece of information that the log
contains.

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 14:06:24 -0700
Processing by UsersController#index as */*
  User Load (0.4ms)  SELECT "users".* FROM "users"
Completed 200 OK in 3ms (Views: 1.9ms | ActiveRecord: 0.4ms)
```

Congrats! Applications, and especially web APIs, are all about
connecting data in your database with the outside world. You've just
done that.

### Creating a User through the API

Let's begin to provide a way to create a new user through the
API. Below is a start for a `create` action. Note that we are not
using an instance variable for user: we will see why these are
very useful when we start working with views, but they aren't
strictly necessary for the controller to work with models or to
interact with the database.

```ruby
# app/controller/users_controller.rb
def create
  user = User.new(params[:user].permit(:user_attributes_here))
  # replace the `user_attributes_here` with the actual attribute keys
  user.save!
  render json: user
end
```

Go ahead and make a POST request to create a new user with Postman. Make
sure to nest your params currently! The `UsersController#create` method is
written expecting that all user params will be nested under the key `:user`
in the params hash.

This namespacing of all user params under `:user` leverages mass-assignment
to set all the uploaded attributes at once. This is an extremely common
Rails pattern: pretty much every time we upload parameters we will nest
them under an inner hash to use for mass assignment.

### Handling Submission Errors

What if the user doesn't upload valid parameters for a new user? Try making
the same request as before but with no email param, only a name.

This doesn't upload the required email attribute. The controller will
create a `user` object, but when it calls `save!` the validation will
fail and an error will be raised.

To inform the user of what went wrong, it is typical to send back
error messages. Let's modify our controller code to send back the
errors as JSON in the event of failure:

```ruby
def create
  user = User.new(params[:user].permit(:name, :email))
  if user.save
    render json: user
  else
    render json: user.errors.full_messages, status: :unprocessable_entity
  end
end
```

Note that if the save of the user fails, we send back the errors to
the client. We also set the status code. By default the status code
will be 200 (OK); if something has gone wrong, use a non-200 code to
indicate this. In this case, we will return a status code
of 422. Rails gives us names for these various codes so that the code
is a bit more semantic. Here is a list of the
[Rails status code names][rails-codes].

[rails-codes]: http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option

Make the request again. You should see the error message displayed in Postman.

Now build some other controller actions:

* show
* update (you'll want to use `ActiveRecord::Base#update_attributes`)
* destroy

Think about what each action's purpose is, what
data is coming in (params), what your controller needs to do with
models, and what it ultimately should render. Test each of them out
in Postman as you go!

While you're at it, try refactoring the `params[...].permit(...)`
stuff into its own method. If you need an example, check out the
[controllers reading][strong-params-example].

[strong-params-example]: ../../readings/basic-controllers.md#drying-out-strong-parameters


##################################################
-----------------------------------------

# Art Share Api

We're going to continue building on the API we built in the first
routes project. Our goal is to build an application to store, share, and
comment on artwork, as well as search for users.

Each user has a set of artworks that they own/control. These artworks
can also be shared with other users. An artwork that has been shared
with one or more other users will be visible to those users, but the
artwork still 'belongs to' the original user.

Although we will maintain this conceptual distinction between a user's
own artworks vs. the artworks that have been shared with that user, we
will eventually write an index method that will combine both types of a
user's viewable artworks together so that we can see any art made by or
shared with that user.

## Learning Goals

* Be able to write Active Record models quickly
* Know how to write a `user_params` method
* Be able to write the five API RESTful controller methods
* Know how to test your API endpoints with Postman
* Know how to create and destroy join table records via controller
methods
* Know how a nested route works

## Phase I: Data Layer

### Overview

You almost always start with the data layer when you're thinking about
adding functionality. Questions to consider include the following: What
pieces of data are necessary to implement the functionality you need?
What changes need to be made to the database schema? What models do you
need? What associations and validations?

In this first phase we're going to add the tables for users, artworks,
and artwork shares. We are also going to write validations and
associations linking them.

### Instructions

#### User

For the `user` table you should have `name` and `email` columns from the
first routes project. Change your User model so that you only have one
column: `username`. Write new migrations to accomplish this. Enforce
presence and uniqueness of `username` at both ActiveRecord and DB
levels.

After you create each table and model, make sure to test that your
associations and validations are working before moving on to the next
step. We want to be ***absolutely sure*** our code is working before we
move on to the next phase, otherwise building our API endpoints will be
needlessly complicated.

#### Artwork

For your `artworks` table you should have the following columns:
`title`, `image_url`, and `artist_id`. All of these should be present.
Add ActiveRecord validations and DB constraints.

Ensure a single user cannot have two artworks with the same title. On
the other hand, two different users can have artworks with the same
title. In other words, two separate artists could both have artworks of
their own named "Untitled", but a single artist should not be able to
have two pieces with that same title.

This means that the `artist_id` and `title` **combination** must be
unique. Enforce this at the DB and model levels. [Here's some help for
the model validation][scoped-uniqueness] To add the DB constraint,
consider what would happen if we added indexing and a uniqueness
constraint to not one, but two columns. [Check this Stack Overflow answer for
more info][multi-column-indexing]

Add an index on `artist_id` so that we can quickly get all the artworks
for a user. Also add associations between `User` and `Artwork`. The
association from `Artwork` to `User` should be called `artist`. Note
that our column in the `artworks` table does not have to be `user_id`
despite being a foreign key to the `users` table. In this case,
`artist_id` is much more descriptive and therefore preferable.

[scoped-uniqueness]: http://guides.rubyonrails.org/active_record_validations.html#uniqueness
[multi-column-indexing]: http://stackoverflow.com/questions/6169996/index-on-multiple-columns-in-ror

#### ArtworkShare

The `artwork_shares` table is a join table. Its whole purpose is to link
a `User` (the person viewing the artwork) with an `Artwork`.

You'll need an `artwork_id` and `viewer_id` column. Again, prefer
columns names that are more semantic (i.e. more descriptive of the
relationship) when possible.

Ensure that both are present. Add the two levels of
validations/constraints. Ensure that a user cannot have a single
`Artwork` shared with them more than once. Also add indices to
`ArtworkShare`'s foreign key columns for fast lookup. NB: we almost
always want to create indexes for any foreign keys, particularly if
those foreign keys will be used in a `has_many` or a `has_one`
relationship.

Then add associations connecting an `ArtworkShare` to both an `Artwork`
and a `User` (name this association `viewer`). Add a through association
`shared_viewers` on `Artwork`. `Artwork#shared_viewers` will return the
set of users with whom an artwork has been shared.

Add a `through` association from `shared_artworks` on `User`.
`User#shared_artworks` will return the set of artworks that have been
shared with that user (*not* the set of artworks that a user has shared
with others).

### Recap

You should now have tables and models for `User`, `Artwork`, and
`ArtworkShare`, as well as the relevent validations and associations.

If you haven't already, now might be the time to seed your `seeds.rb`
file seed data. This is easier than creating seed data in the Rails
console and should you ever drop your database will provide an easy way
to re-populate your tables with testable data.

## Phase II: Users and Artworks API

### Overview

Next let's move to the API layer. The API describes how you will
**expose** your data and specifies how the outside world can interact
with it. Today we'll be using Chrome's Postman plugin to test our API
endpoints. When debugging make sure to reference your Rails server log.
It will provide you will valuable insight as to what's going wrong.

### Instructions

First, make sure the `User` controller actions you created in the
previous project are all working. They should do the following:

* `user_params` helper method

This method should be private. It requires the key `:user` in params,
and permits each of the user attributes as keys in the nested hash.

* `create` (POST `/users`)

Remember to use `if @user.save` to check if validations passed. On
error, this action should render validation errors using
`@user.errors.full_messages`. Set the status code to indicate error.

* `destroy` (DELETE `/users:id`)

Finds the user (we can lookup the id in `params[:id]`) and destroys the
object. Best practice is to render the destroyed user after destroying
it in the database. Use `dependent: :destroy` in the `artworks` and
`artwork_shares` associations on `User`. This ensures that the
associated records are also destroyed.

* `index` (GET `/users`)

Renders all the users in the database.

* `show` (GET `/users/:id`)

Renders a single user, using the `:id` in `params[:id]`.

* `update` (PATCH `/users/:id`)

Finds the requested user. Use `update` with `user_params` to do a
mass-assignment update and save. Render validation errors using
`@user.errors.full_messages`.  *Don't forget the status code!*

Now let's move to the `routes.rb` file. You should already have routes
for the `users` controller from the previous project. Use the `only:`
option for `resources` to restrict to just the five actions above for
the `users` controller. There should be six routes in total; remember
that Rails will generate both `patch` and `put` routes for the `update`
action.

Next, move on to creating `ArtworksController`. Build the same five
actions and params helper method. Your code should look very similar,
but practice this a second time.

**Hint**: For this project, do not write any authentication or
authorization logic. When creating a new `artwork`, require the
uploader submit their `artist_id`. This isn't secure because anyone
could always take your `artist_id` and upload new artworks in your name.
For now, let's assume the users of our service aren't malicious
:-)

### Recap

Congratulations! You should now have tables, models, and controllers for
users and artworks. Before moving on, test that your API endpoints are
working with Postman. Then call over a TA and explain your code.

## Phase III: Sharing `Artworks`

### Overview

Now we're going to add routes and controllers for our `ArtworkShares`.
The `artwork_shares` table is a join table, so while RESTful design
patterns still apply, our `ArtworkShares` controller will look a little
different from the controllers we just wrote. All we need to be able to
do is share and unshare artworks. What controller actions do you think
we'll need?

Once we have sharing working, we'll refactor `ArtworksController#index`
so that it returns artworks either belonging to or shared with a
particular user. In order to make this work we'll need to pass in the
`user_id` to our `index` action so we can filter for the appropriate
works.

### Instructions

Add a new `resources` routes and controller for `ArtworkShare`.
Include the following actions and associated routes.

* `create` (POST `/artwork_shares`)

You'll want to pass the `artwork_id` and the `viewer_id`.
Also, use strong parameters by writing an `artwork_share_params` helper
method that will whitelist the `ArtworkShare` attributes.

* `destroy` (DELETE `/artwork_share/:id`)

This un-shares an `Artwork` with a `User`. To delete a share, the user
should issue a DELETE to `/artwork_shares/123`, where `123` is the id of
the `ArtworkShare` to destroy.

After we create ArtworkShare records, we will want to return the record
to the client. We will want to do the same thing upon deletion of
ArtworkShare records. Both of these routes should conventionally render
the created/destroyed `ArtworkShare` as the response.

We won't need any of the other routes, so you can use `only:` to
restrict them.

Use Postman to make sure that your controller's `create` and `destroy`
actions work properly. Remember, our validations should prevent us from
sharing the same `artwork` with the same `user` more than once.

#### User's Artworks: nested routes

We want to be able to fetch the `Artwork`s of a particular user.
However, right now a GET to `/artworks` gets all of the artworks in the
system.

Let's add a new, nested resource, `/users/:user_id/artworks`, so that
we can get the artworks for a given user. We'll only need the `index`
action for this.

You may remove the `index` action from the top-level `artworks`
resource. This will modify our API so that a user can't download all the
artworks in one go, but instead only per-user. For example, you will
be able to get user 1's artworks through `GET /users/1/artworks`, user
2's through `GET /users/2/artworks`, etc.

The nested resource will still hit `ArtworksController#index`. Rewrite
the `index` method to return:

*  the `Artwork`s owned by a user ***and***
*  the `Artwork`s shared with the user.

You can access the specified user through `params[:user_id]` because it
is part of the nested route.

Use Postman to make sure your modified `index` method in the
`ArtworksController` returns all art owned by and shared with a user.

### Recap

At this point in the project you should be able to create
`ArtworkShares` with  Postman. Artworks shared with a particular user
should also be included in data returned by a `GET` request to
`ArtworksController#index`.

## Phase IV: Comments

### Overview

Now it's time to add commenting functionality to our application so our
users can comment on a piece of artwork. By the time we're done, we want
to be able to retrieve both a specific user's comments as well as
comments left on a specific artwork. To do with we'll have our
`CommentsController#index` method return commments based on the params
provided by our request.

### Instructions

First create a comments table that has a foreign key for both user and
artwork. We'll also want a `body` column that contains the text of the
comment. On what columns should we add an index?

Our users and artworks will both `have_many` comments. A comment should
`belong_to` a author (the user who left that comment) and artwork. Write
these associations now. Remember to include `dependent: :destroy` when
necessary. For instance, when an artwork or user is removed from the
database, we don't want their associated comments to persist.

Before moving on test that these associations work.

Once we know our table and model have been set up correctly, it's time
to make our controller. The `CommentsController` should have `create`,
`destroy`, and `index` actions.

In order to retrieve comments for an artwork or a user we want our
`index` action to handle some additional params. In particular, we want
to be able to pass in a `user_id` or a `artwork_id`. By checking if
either is present we can then retrieve the comments just for that user
or artwork. Update your `comment_params` accordingly.

### Recap

It should now be possible to make `GET` requests to
`CommentsController#index` and depending on the params provided either
return comments made by a particular user or comments made on a
particular piece of artwork.

## Phase V: Search

### Overview

Now let's add search functionality to our application so users can
search for other users by name. To do this we won't need to change any
routes. We can just edit the `index` action in our `User` controller.

In `UsersController#index` check if a `query` is present in the request
params. If it is, use that query to filter the users returned by the
`index` action. If there is no query, just return all users as usual.

Discuss with your partner the best way to write your query method.
Here's a [good place to start][postgres-search].

## Bonus Phase I: Likes

In this phase we'll implement likes using polymorphic associations.
Users should be able to like both comments and artworks. Read these
[Rails docs][polymorphic-associations] on polymorphic associations to
get started.

Then discuss with your partner how you plan to approach this feature.
We'd like to be able to call associations on a user and return their
liked comments and artworks. We also want to be able to call an
association on comments and artworks to get the users who have liked
them.

Once you have a plan call over a TA and explain it to them. Then get
coding!

## Bonus Phase II: Favorite Artworks

Let's also allow users to favorite artworks. This will require
additional columns to artworks (for favoriting of artworks by their
owner) and shared artworks (for favoriting of artworks shared to a
user). Use a semantic custom route to accomplish this.
[Hint.][more-restful-actions]

## Bonus Phase III: Artwork Collections

And finally, users should be able to add artworks to artwork
collections. Allow each user to have many collections. Artworks can also
belong to more than one collection. What sort of table will you need to
make this work?

[poly-assoc]: http://guides.rubyonrails.org/association_basics.html#polymorphic-associations
[concerns-for-models]: http://signalvnoise.com/posts/3372-put-chubby-models-on-a-diet-with-concerns
[postgres-search]: https://www.postgresql.org/docs/8.3/static/functions-matching.html
[polymorphic-associations]: http://guides.rubyonrails.org/association_basics.html#polymorphic-associations
[more-restful-actions]: http://guides.rubyonrails.org/v3.2.14/routing.html#adding-more-restful-actions
